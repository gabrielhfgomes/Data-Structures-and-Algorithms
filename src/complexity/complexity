

Stack Array-Based e SinglyLinkedList-Based:
    - push: O(1)
    - pop:  O(1)

Queue Array-Based com estratégia do f e SinglyLinkedList:
    - enqueue: O(1)
    - dequeue: O(1)

Deque:
    - addFirst:    O(1)
    - addLast:    O(1)
    - removeFirst: O(1)
    - removeLast:  O(1)

ArrayList:
    - add:      O(n)
    - set:      O(1)
    - remove:   O(n)
    - get:      O(1)

PositionalList:
    - addFirst, addLast, addBefore, addAfter: O(1)
    - set:                                    O(1)
    - remove:                                 O(1)

LinkedBinaryTree:
    - todos métodos: O(1)   
    - depth: O(dp + 1) dp = depth do parent
    - height: O(n)

UnsortedPriorityQueue implementada com LinkedPositionalList:
    - insert: O(1)
    - removeMin, min: O(n)

SortedPriorityQueue implementada com LinkedPositionalList:
    - insert: O(n)
    - remove, min: O(1)

Selection-Sort com PriorityQueue ou PqSort UnsortedPriorityQueue
    - O(n2)

Insertion-Sort com PriorityQueue ou PqSort SortedPriorityQueue
    - O(n2)

HeapPriorityQueue
    - insert: O(log n)
    - remove: O(log n)
    - min: O(1)

UnsortedTableMap
    - put: O(1)
    - get: O(n)
    - remove: O(n)

SortedTableMap
    - put:   O(n)/O(log n)
    - get:   O(log n)
    - remove:O(n)

HashTables:
            Esperado:   Pior caso:
- get:        O(1)         O(n)
- put:        O(1)         O(n)
- remove:     O(1)         O(n)

Skip Lists:
              Esperado:
    - search: O(log n)
    - update: O(log n)
    - remove: O(log n)

Merge Sort:
    O(n log n)
    -> 2n + 2T(n/2)
    -> 4n + 4T(n/4)
    -> 6n + 8T(n/8)
    -> 8n + 16T(n/16)
        ...
    -> 2in + 2 elevado i T(n/2 elevado i) sendo 2 elevado i = n, i = log n
    -> 2 log n * n + 2 elevado log n  * T(n/2 elevado log n)
      = n + 2n log n
      = O(n log n)

Quick Sort
    - Pior caso:      O(n2) muito IMPROVAVEL
    - Tempo experado: O (n log n)


Binary Search Tree
    - TreeSearch: pior caso altura da arvore h,  O(log n)
    - Insertion, Removal: pior caso altura da arvore h, O(log n)

AVL Tree
    - get,put,remove: O(log n)

Splay Tree
    - O(log n)

(2,4) Tree
    - O(log n)

Red Black Tree
    - O(log n)


Graphs
    Edge List
    - numVertices, numEdges: O(1)
    - vertices: O(n)
    - edges: O(m)
    - getEdge, outDegree, inDegree: O(m)
    - insertVertex, insertEdge, removeEdge: O(1)
    - removeVertex: O(m)

    Adjacency List
    - numVertices, numEdges: O(1)
    - vertices: O(n)
    - edges: O(m)
    - getEdge: O(min(deg(u),deg(v)))
    - outDegree, inDegree: O(1)
    - outGoingEdges, incomingEdges: O(deg(v))
    - insertVertex, insertEdge, removeEdge: O(1)

    Adjacency Map
    - numVertices, numEdges: O(1)
    - vertices: O(n)
    - edges: O(m)
    - getEdge: O(1) esperado
    - outDegree, inDegree: O(1)
    - outGoingEdges, incomingEdges: O(deg(v))
    - insertVertex, insertEdge, removeEdge: O(1)

    DFS
    O(n+m)

    BFS
    O(n+m)


    Transitive Closure com DFS
    - O(n(n+m))

    Floyd Warshall
    - O(n3)




